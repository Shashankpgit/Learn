# tf.sh File - Complete Documentation

## Overview
The `tf.sh` file is a critical configuration file generated by the `create_tf_backend` function that contains environment variables required for Terraform remote state management in Azure. This file serves as the bridge between Azure backend infrastructure and Terraform operations.

## File Generation Process

### When It's Created
- **Function**: `create_tf_backend`
- **Location**: Current working directory (terraform/azure/{environment}/)
- **Timing**: After Azure backend resources are successfully created

### Generation Code
```bash
# Export Terraform backend details to a file
echo "export AZURE_TERRAFORM_BACKEND_RG=$RESOURCE_GROUP_NAME" > tf.sh
echo "export AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT=$STORAGE_ACCOUNT_NAME" >> tf.sh
echo "export AZURE_TERRAFORM_BACKEND_CONTAINER=$CONTAINER_NAME" >> tf.sh
echo "export AZURE_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> tf.sh
```

### Variable Construction
```bash
# Input from global-values.yaml
building_block="sunbird"
environment_name="demo"

# Azure context
ID=$(az account show | jq -r .tenantId | cut -d '-' -f1)  # First 8 chars of tenant ID
SUBSCRIPTION_ID=$(az account show | jq -r .id)

# Constructed names
RESOURCE_GROUP_NAME="${building_block}-${environment_name}"           # sunbird-demo
STORAGE_ACCOUNT_NAME="${environment_name}tfstate$ID"                  # demotfstate12345678
CONTAINER_NAME="${environment_name}tfstate"                           # demotfstate
```

## File Content Structure

### Example tf.sh Content
```bash
export AZURE_TERRAFORM_BACKEND_RG=sunbird-demo
export AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT=demotfstate12345678
export AZURE_TERRAFORM_BACKEND_CONTAINER=demotfstate
export AZURE_SUBSCRIPTION_ID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
```

### Variable Breakdown

| Variable | Purpose | Example Value | Description |
|----------|---------|---------------|-------------|
| `AZURE_TERRAFORM_BACKEND_RG` | Resource Group Name | `sunbird-demo` | Contains the storage account for state files |
| `AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT` | Storage Account Name | `demotfstate12345678` | Stores Terraform state files |
| `AZURE_TERRAFORM_BACKEND_CONTAINER` | Blob Container Name | `demotfstate` | Container within storage account for state files |
| `AZURE_SUBSCRIPTION_ID` | Azure Subscription ID | `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` | Azure subscription context |

## File Usage in Installation Process

### 1. Loading Environment Variables
```bash
# In create_tf_resources function
source tf.sh  # Loads all environment variables into current shell
```

### 2. Terragrunt Backend Configuration
The variables are used by Terragrunt to generate `backend.tf` files:

```hcl
# terragrunt.hcl uses these environment variables
generate "backend" {
  path      = "backend.tf"
  if_exists = "overwrite_terragrunt"
  contents = <<EOF
terraform {
  backend "azurerm" {
    resource_group_name  = "${get_env("AZURE_TERRAFORM_BACKEND_RG")}"
    storage_account_name = "${get_env("AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT")}"
    container_name       = "${get_env("AZURE_TERRAFORM_BACKEND_CONTAINER")}"
    key                  = "${path_relative_to_include()}/terraform.tfstate"
  }
}
EOF
}
```

### 3. Generated backend.tf Files
Each Terraform module gets a `backend.tf` file:
```hcl
terraform {
  backend "azurerm" {
    resource_group_name  = "sunbird-demo"
    storage_account_name = "demotfstate12345678"
    container_name       = "demotfstate"
    key                  = "network/terraform.tfstate"
  }
}
```

## State File Organization

### Container Structure
```
Azure Storage Container: demotfstate/
├── network/terraform.tfstate              # Network infrastructure state
├── aks/terraform.tfstate                  # Kubernetes cluster state
├── storage/terraform.tfstate              # Storage accounts state
├── keys/terraform.tfstate                 # Security keys state
├── random_passwords/terraform.tfstate     # Generated passwords state
├── upload-files/terraform.tfstate         # File upload operations state
└── output-file/terraform.tfstate          # Output configurations state
```

### State File Benefits
- **Centralized Storage**: All team members use same state
- **State Locking**: Prevents concurrent modifications
- **Backup & Recovery**: State files are backed up in Azure
- **Collaboration**: Multiple developers can work on same infrastructure
- **Audit Trail**: All changes tracked in Azure Storage logs

## File Lifecycle

### Creation Phase
1. `create_tf_backend` function executes
2. Azure resources created successfully
3. `tf.sh` file generated with correct variables
4. File ready for use by subsequent functions

### Usage Phase
1. `create_tf_resources` sources the file
2. Environment variables loaded into shell
3. Terragrunt uses variables for backend configuration
4. All Terraform modules use remote state

### Maintenance Phase
- File persists throughout installation
- Used by destroy operations
- Required for any Terraform state operations
- Should be backed up for disaster recovery

## Security Considerations

### Sensitive Information
- **Subscription ID**: Identifies Azure subscription
- **Resource Names**: Could reveal infrastructure details
- **Storage Account**: Contains all infrastructure state

### Protection Measures
- File should have restricted permissions: `chmod 600 tf.sh`
- Should not be committed to version control
- Should be backed up securely
- Access should be limited to authorized personnel

### Best Practices
```bash
# Secure the file
chmod 600 tf.sh

# Backup the file
cp tf.sh tf.sh.backup

# Verify variables are loaded
source tf.sh
echo $AZURE_TERRAFORM_BACKEND_RG
```

## Troubleshooting

### Common Issues

#### Issue 1: File Not Found
```bash
Error: tf.sh: No such file or directory
```
**Solution**: Ensure `create_tf_backend` completed successfully

#### Issue 2: Empty Variables
```bash
Error: AZURE_TERRAFORM_BACKEND_RG is not set
```
**Solution**: 
```bash
source tf.sh  # Load variables
# or
export $(cat tf.sh | xargs)  # Alternative loading method
```

#### Issue 3: Permission Denied
```bash
bash: tf.sh: Permission denied
```
**Solution**:
```bash
chmod +x tf.sh
source tf.sh
```

#### Issue 4: Backend Initialization Fails
```bash
Error: Failed to configure the backend "azurerm"
```
**Solution**: Verify Azure resources exist and variables are correct:
```bash
az storage account show --name $AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT --resource-group $AZURE_TERRAFORM_BACKEND_RG
```

### Validation Commands
```bash
# Check if file exists and has content
ls -la tf.sh
cat tf.sh

# Verify Azure resources exist
source tf.sh
az group show --name $AZURE_TERRAFORM_BACKEND_RG
az storage account show --name $AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT --resource-group $AZURE_TERRAFORM_BACKEND_RG
az storage container show --name $AZURE_TERRAFORM_BACKEND_CONTAINER --account-name $AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT

# Test Terraform backend connectivity
terraform init
```

## Integration Points

### With create_tf_backend Function
- **Output**: Generates tf.sh file
- **Dependencies**: Requires successful Azure resource creation
- **Validation**: File creation indicates successful backend setup

### With create_tf_resources Function
- **Input**: Sources tf.sh file
- **Usage**: Loads environment variables for Terraform operations
- **Dependencies**: Must exist before Terraform initialization

### With Terragrunt Configuration
- **Integration**: Variables used in terragrunt.hcl
- **Backend Generation**: Creates backend.tf files dynamically
- **State Management**: Enables remote state for all modules

## Recovery Procedures

### If tf.sh is Lost
1. **Recreate from Azure resources**:
```bash
# Get resource group name (if known pattern)
RESOURCE_GROUP_NAME="sunbird-demo"

# Get storage account name
STORAGE_ACCOUNT_NAME=$(az storage account list --resource-group $RESOURCE_GROUP_NAME --query "[0].name" -o tsv)

# Get container name (usually follows pattern)
CONTAINER_NAME="demotfstate"

# Get subscription ID
SUBSCRIPTION_ID=$(az account show --query id -o tsv)

# Recreate tf.sh
echo "export AZURE_TERRAFORM_BACKEND_RG=$RESOURCE_GROUP_NAME" > tf.sh
echo "export AZURE_TERRAFORM_BACKEND_STORAGE_ACCOUNT=$STORAGE_ACCOUNT_NAME" >> tf.sh
echo "export AZURE_TERRAFORM_BACKEND_CONTAINER=$CONTAINER_NAME" >> tf.sh
echo "export AZURE_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> tf.sh
```

2. **Verify and test**:
```bash
source tf.sh
terraform init
```

### If Backend Resources are Lost
1. **Re-run create_tf_backend function**:
```bash
./install.sh create_tf_backend
```

2. **Import existing state** (if needed):
```bash
terraform import azurerm_resource_group.example /subscriptions/{subscription-id}/resourceGroups/{resource-group-name}
```

## Best Practices for Team Usage

### For New Team Members
1. **Always source tf.sh** before Terraform operations
2. **Verify variables are loaded** before proceeding
3. **Keep backup copy** of tf.sh file
4. **Don't modify manually** unless necessary

### For DevOps Teams
1. **Automate tf.sh validation** in CI/CD pipelines
2. **Monitor backend resource health** regularly
3. **Implement backup strategies** for state files
4. **Document any manual modifications**

### For Production Environments
1. **Restrict access** to tf.sh file
2. **Use separate backends** for different environments
3. **Implement state file encryption**
4. **Regular backup verification**

## Conclusion

The `tf.sh` file is a critical component that enables the entire Terraform infrastructure management for Sunbird-ED. It serves as the configuration bridge between Azure backend resources and Terraform operations, ensuring consistent and reliable state management across the entire installation process.

Understanding this file's purpose, content, and usage is essential for anyone working with the Sunbird-ED infrastructure deployment and maintenance.